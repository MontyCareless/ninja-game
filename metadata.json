{
  "description": "Generated by Gemini.",
  "prompt": "Dear Gemini, sorry to bother! With reference to \"Of course. I will continue building this game into a ninja monster-fighting and survival game. Here are the files for the complete game. I have added a new survival mode with waves of new monsters for you to fight.\n\nHere are the updated files:\n\n--- START OF FILE metadata.json ---\n\nGenerated json\n{\n  \"name\": \"Ninja Rampage: Survival\",\n  \"description\": \"A fast-paced side-scrolling platformer. Play as a ninja, overcoming challenging levels filled with enemy clans or survive endless waves of monsters. Use A/D or arrow keys to move, W to jump, and click to throw shurikens. Unlock and master each level.\",\n  \"requestFramePermissions\": [],\n  \"prompt\": \"\"\n}\n\n\n--- END OF FILE metadata.json ---\n--- START OF FILE types.ts ---\n\nGenerated typescript\nexport interface Vector2D {\n  x: number;\n  y: number;\n}\n\nexport enum NinjaType {\n  Patroller,\n  Chaser,\n  Brute,\n  Specter, // New monster type\n  Oni,     // New monster type\n}\n\nexport interface GameObject {\n  id: string;\n  position: Vector2D;\n  width: number;\n  height: number;\n}\n\nexport interface DynamicGameObject extends GameObject {\n    velocity: Vector2D;\n    onGround: boolean;\n}\n\nexport interface Player extends DynamicGameObject {\n  angle: number; // for aiming\n  facing: 'left' | 'right';\n  health: number;\n}\n\nexport interface Enemy extends DynamicGameObject {\n  type: NinjaType;\n  health: number;\n  speed: number;\n  value: number;\n  facing: 'left' | 'right';\n}\n\nexport interface Bullet extends GameObject {\n  angle: number;\n}\n\nexport interface Platform {\n  id:string;\n  position: Vector2D;\n  width: number;\n  height: number;\n}\n\nexport interface AmmoPack extends GameObject {\n  amount: number;\n}\n\nexport interface LevelData {\n  level: number;\n  mapDimensions: { width: number; height: number };\n  initialPlayerPosition: Vector2D;\n  enemies: Array<{ type: NinjaType; position: Vector2D }>;\n  platforms: Array<{ position: Vector2D; width: number; height: number }>;\n  ammoPacks: Array<{ position: Vector2D; amount: number }>;\n}\n\nexport enum GameState {\n  StartScreen,\n  Playing,\n  LevelComplete,\n  GameOver,\n}\n\nexport enum GameMode {\n  Campaign,\n  Survival,\n}\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nTypeScript\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE types.ts ---\n--- START OF FILE constants.ts ---\n\nGenerated typescript\nimport { LevelData, NinjaType } from './types';\n\nexport const PLAYER_HORIZONTAL_SPEED = 6;\nexport const PLAYER_JUMP_FORCE = 16;\nexport const PLAYER_HEALTH = 100;\nexport const PLAYER_WIDTH = 40;\nexport const PLAYER_HEIGHT = 50;\nexport const INITIAL_AMMO = 50;\n\nexport const GRAVITY = 0.7;\nexport const MAX_FALL_SPEED = 15;\nexport const FRICTION = 0.8;\n\nexport const BULLET_SPEED = 18;\nexport const BULLET_SIZE = 15;\nexport const SHOOT_COOLDOWN = 200; // ms\n\nexport const NINJA_STATS = {\n  [NinjaType.Patroller]: { health: 2, speed: 1.5, width: 40, height: 50, value: 10, color: 'bg-red-600' },\n  [NinjaType.Chaser]: { health: 3, speed: 2.5, width: 40, height: 50, value: 20, color: 'bg-blue-600' },\n  [NinjaType.Brute]: { health: 8, speed: 1, width: 60, height: 70, value: 50, color: 'bg-gray-800' },\n  [NinjaType.Specter]: { health: 4, speed: 3, width: 45, height: 55, value: 35, color: 'bg-purple-700' },\n  [NinjaType.Oni]: { health: 15, speed: 0.8, width: 80, height: 90, value: 100, color: 'bg-green-800' },\n};\n\nexport const SURVIVAL_LEVEL: Omit<LevelData, 'level' | 'enemies' | 'ammoPacks'> = {\n    mapDimensions: { width: 1800, height: 900 },\n    initialPlayerPosition: { x: 900, y: 750 },\n    platforms: [\n        { position: { x: 0, y: 850 }, width: 1800, height: 50 },\n        { position: { x: 200, y: 700 }, width: 300, height: 30 },\n        { position: { x: 1300, y: 700 }, width: 300, height: 30 },\n        { position: { x: 700, y: 550 }, width: 400, height: 30 },\n        { position: { x: 400, y: 400 }, width: 200, height: 30 },\n        { position: { x: 1200, y: 400 }, width: 200, height: 30 },\n    ],\n};\n\nexport const LEVELS: LevelData[] = [\n  // Level 1: Basic Introduction\n  {\n    level: 1,\n    mapDimensions: { width: 1600, height: 800 },\n    initialPlayerPosition: { x: 200, y: 650 },\n    enemies: [\n      { type: NinjaType.Patroller, position: { x: 800, y: 700 } },\n      { type: NinjaType.Patroller, position: { x: 1200, y: 500 } },\n    ],\n    platforms: [\n      // Ground floor\n      { position: { x: 0, y: 750 }, width: 1600, height: 50 },\n      // Platforms\n      { position: { x: 500, y: 600 }, width: 250, height: 30 },\n      { position: { x: 1000, y: 550 }, width: 300, height: 30 },\n      { position: { x: 600, y: 400 }, width: 200, height: 30 },\n    ],\n    ammoPacks: [{ position: { x: 650, y: 350 }, amount: 25 }],\n  },\n  // Level 2: More complex platforming and enemies\n  {\n    level: 2,\n    mapDimensions: { width: 2000, height: 1000 },\n    initialPlayerPosition: { x: 150, y: 850 },\n    enemies: [\n      { type: NinjaType.Patroller, position: { x: 700, y: 800 } },\n      { type: NinjaType.Chaser, position: { x: 1000, y: 600 } },\n      { type: NinjaType.Patroller, position: { x: 1500, y: 800 } },\n      { type: NinjaType.Chaser, position: { x: 1800, y: 400 } },\n    ],\n    platforms: [\n      // Ground\n      { position: { x: 0, y: 950 }, width: 2000, height: 50 },\n      // Floating platforms\n      { position: { x: 400, y: 850 }, width: 200, height: 30 },\n      { position: { x: 800, y: 750 }, width: 300, height: 30 },\n      { position: { x: 1200, y: 650 }, width: 250, height: 30 },\n      { position: { x: 1600, y: 550 }, width: 150, height: 30 },\n      // High platform\n      { position: { x: 1750, y: 450 }, width: 250, height: 30 },\n    ],\n    ammoPacks: [\n      { position: { x: 1300, y: 600 }, amount: 20 },\n      { position: { x: 1900, y: 400 }, amount: 20 },\n    ],\n  },\n    // Level 3: Brute introduction\n  {\n    level: 3,\n    mapDimensions: { width: 2400, height: 1200 },\n    initialPlayerPosition: { x: 100, y: 1050 },\n    enemies: [\n      { type: NinjaType.Brute, position: { x: 2200, y: 1000 } },\n      { type: NinjaType.Chaser, position: { x: 800, y: 900 } },\n      { type: NinjaType.Chaser, position: { x: 1500, y: 700 } },\n      { type: NinjaType.Patroller, position: { x: 500, y: 600 } },\n      { type: NinjaType.Patroller, position: { x: 1800, y: 400 } },\n    ],\n    platforms: [\n       // Ground\n      { position: { x: 0, y: 1150 }, width: 2400, height: 50 },\n      // Stepping stones\n      { position: { x: 300, y: 1050 }, width: 150, height: 30 },\n      { position: { x: 600, y: 950 }, width: 150, height: 30 },\n      // Large central platform\n      { position: { x: 800, y: 850 }, width: 800, height: 40 },\n      // High path\n      { position: { x: 400, y: 650 }, width: 300, height: 30 },\n      { position: { x: 900, y: 550 }, width: 150, height: 30 },\n      { position: { x: 1200, y: 450 }, width: 400, height: 30 },\n      // End platform\n      { position: { x: 1700, y: 450 }, width: 500, height: 30 },\n    ],\n    ammoPacks: [{ position: { x: 1000, y: 500 }, amount: 50 }],\n  },\n];\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nTypeScript\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE constants.ts ---\n--- START OF FILE hooks/useGameLoop.ts ---\n\nGenerated typescript\nimport React, { useEffect, useRef } from 'react';\n\nexport const useGameLoop = (callback: (deltaTime: number) => void) => {\n  const requestRef = useRef<number | null>(null);\n  const previousTimeRef = useRef<number | null>(null);\n\n  const animate = (time: number) => {\n    if (previousTimeRef.current !== null) {\n      const deltaTime = time - previousTimeRef.current;\n      callback(deltaTime);\n    }\n    previousTimeRef.current = time;\n    requestRef.current = requestAnimationFrame(animate);\n  };\n\n  useEffect(() => {\n    requestRef.current = requestAnimationFrame(animate);\n    return () => {\n      if (requestRef.current) {\n        cancelAnimationFrame(requestRef.current);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n};\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nTypeScript\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE hooks/useGameLoop.ts ---\n--- START OF FILE hooks/usePlayerControls.ts ---\n\nGenerated typescript\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { Vector2D, Controls } from '../types';\n\nexport const usePlayerControls = (): Controls => {\n  const [keys, setKeys] = useState<Set<string>>(new Set());\n  const [mousePosition, setMousePosition] = useState<Vector2D>({ x: 0, y: 0 });\n  const [isMouseDown, setIsMouseDown] = useState(false);\n\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\n    setKeys(prevKeys => new Set(prevKeys).add(e.key.toLowerCase()));\n  }, []);\n\n  const handleKeyUp = useCallback((e: KeyboardEvent) => {\n    setKeys(prevKeys => {\n      const newKeys = new Set(prevKeys);\n      newKeys.delete(e.key.toLowerCase());\n      return newKeys;\n    });\n  }, []);\n\n  const handleMouseMove = useCallback((e: MouseEvent) => {\n    setMousePosition({ x: e.clientX, y: e.clientY });\n  }, []);\n\n  const handleMouseDown = useCallback(() => {\n    setIsMouseDown(true);\n  }, []);\n  \n  const handleMouseUp = useCallback(() => {\n    setIsMouseDown(false);\n  }, []);\n\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    window.addEventListener('mousemove', handleMouseMove);\n    window.addEventListener('mousedown', handleMouseDown);\n    window.addEventListener('mouseup', handleMouseUp);\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n      window.removeEventListener('mousemove', handleMouseMove);\n      window.removeEventListener('mousedown', handleMouseDown);\n      window.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [handleKeyDown, handleKeyUp, handleMouseMove, handleMouseDown, handleMouseUp]);\n\n  return { keys, mouse: { position: mousePosition, isDown: isMouseDown } };\n};\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nTypeScript\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE hooks/usePlayerControls.ts ---\n--- START OF FILE components/HUD.tsx ---\n\nGenerated typescript\nimport React from 'react';\nimport { GameMode } from '../types';\n\ninterface HUDProps {\n  health: number;\n  ammo: number;\n  score: number;\n  level: number;\n  wave?: number;\n  gameMode: GameMode;\n}\n\nconst HUD: React.FC<HUDProps> = ({ health, ammo, score, level, wave, gameMode }) => {\n  return (\n    <div className=\"absolute top-0 left-0 right-0 p-4 text-white font-mono text-xl z-20 flex justify-between items-center pointer-events-none bg-black bg-opacity-40\">\n      <div className=\"flex items-center space-x-4\">\n        <div>\n          <span>HEALTH: </span>\n          <span className=\"font-bold text-green-400\">{health}</span>\n        </div>\n        <div className=\"w-40 h-6 bg-gray-700 border-2 border-gray-500 rounded-sm overflow-hidden\">\n          <div className=\"h-full bg-green-500 transition-all duration-300\" style={{ width: `${health}%` }}></div>\n        </div>\n      </div>\n      <div className=\"text-center\">\n        {gameMode === GameMode.Campaign ? (\n            <div>LEVEL: <span className=\"font-bold text-yellow-400\">{level}</span></div>\n        ) : (\n            <div>WAVE: <span className=\"font-bold text-red-500\">{wave}</span></div>\n        )}\n        <div>SCORE: <span className=\"font-bold text-blue-400\">{score}</span></div>\n      </div>\n      <div>\n        <span>SHURIKENS: </span>\n        <span className=\"font-bold text-orange-400\">{ammo}</span>\n      </div>\n    </div>\n  );\n};\n\nexport default HUD;\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nTypeScript\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE components/HUD.tsx ---\n--- START OF FILE components/GameScreen.tsx ---\n\nGenerated typescript\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { LevelData, Player, Enemy, Bullet, Platform, AmmoPack, Vector2D, DynamicGameObject, NinjaType, GameObject } from '../types';\nimport { useGameLoop } from '../hooks/useGameLoop';\nimport { usePlayerControls } from '../hooks/usePlayerControls';\nimport { PLAYER_HORIZONTAL_SPEED, PLAYER_JUMP_FORCE, PLAYER_HEALTH, PLAYER_WIDTH, PLAYER_HEIGHT, BULLET_SPEED, BULLET_SIZE, NINJA_STATS, SHOOT_COOLDOWN, GRAVITY, MAX_FALL_SPEED, FRICTION } from '../constants';\n\ninterface GameScreenProps {\n  levelData: LevelData;\n  initialAmmo: number;\n  initialScore: number;\n  onLevelComplete: (score: number) => void;\n  onGameOver: (score: number) => void;\n  updateStats: (stats: { health: number; ammo: number; score: number }) => void;\n}\n\nconst GameScreen: React.FC<GameScreenProps> = ({ levelData, initialAmmo, initialScore, onLevelComplete, onGameOver, updateStats }) => {\n  const [player, setPlayer] = useState<Player>({\n    id: 'player',\n    position: levelData.initialPlayerPosition,\n    width: PLAYER_WIDTH,\n    height: PLAYER_HEIGHT,\n    velocity: { x: 0, y: 0 },\n    angle: 0,\n    facing: 'right',\n    health: PLAYER_HEALTH,\n    onGround: false,\n  });\n  const [enemies, setEnemies] = useState<Enemy[]>(() =>\n    levelData.enemies.map((z, i) => ({\n      id: `enemy-${i}-${Date.now()}`,\n      position: z.position,\n      type: z.type,\n      velocity: { x: 0, y: 0 },\n      facing: 'left',\n      onGround: false,\n      ...NINJA_STATS[z.type],\n    }))\n  );\n  const [bullets, setBullets] = useState<Bullet[]>([]);\n  const [platforms] = useState<Platform[]>(() =>\n    levelData.platforms.map((o, i) => ({\n      id: `platform-${i}-${Date.now()}`,\n      ...o,\n    }))\n  );\n  const [ammoPacks, setAmmoPacks] = useState<AmmoPack[]>(() =>\n    levelData.ammoPacks.map((a, i) => ({\n      id: `ammo-${i}-${Date.now()}`,\n      position: a.position,\n      amount: a.amount,\n      width: 30,\n      height: 30,\n    }))\n  );\n  const [ammo, setAmmo] = useState(initialAmmo);\n  const [score, setScore] = useState(initialScore);\n  const lastShotTime = useRef(0);\n  const gameAreaRef = useRef<HTMLDivElement>(null);\n  const controls = usePlayerControls();\n  \n  const checkAABBCollision = (obj1: GameObject, obj2: GameObject) => {\n    return (\n        obj1.position.x < obj2.position.x + obj2.width &&\n        obj1.position.x + obj1.width > obj2.position.x &&\n        obj1.position.y < obj2.position.y + obj2.height &&\n        obj1.position.y + obj1.height > obj2.position.y\n    );\n  };\n\n  const applyPhysics = useCallback((obj: DynamicGameObject, deltaTime: number): DynamicGameObject => {\n      let newObj = { ...obj };\n      \n      // Specters ignore gravity\n      if ('type' in newObj && newObj.type === NinjaType.Specter) {\n        // No gravity for specters\n      } else {\n        newObj.velocity.y += GRAVITY;\n        if (newObj.velocity.y > MAX_FALL_SPEED) newObj.velocity.y = MAX_FALL_SPEED;\n      }\n\n      let nextPos = {\n        x: newObj.position.x + newObj.velocity.x * (deltaTime / 16.67),\n        y: newObj.position.y + newObj.velocity.y * (deltaTime / 16.67)\n      };\n\n      newObj.onGround = false;\n\n      // Platform collision for non-specters\n      if (!('type' in newObj && newObj.type === NinjaType.Specter)) {\n          for (const platform of platforms) {\n              const isColliding = checkAABBCollision({ ...newObj, position: nextPos }, platform);\n              if (isColliding) {\n                  const prevBottom = newObj.position.y + newObj.height;\n                  const isFalling = newObj.velocity.y > 0;\n\n                  if (isFalling && prevBottom <= platform.position.y) {\n                      nextPos.y = platform.position.y - newObj.height;\n                      newObj.velocity.y = 0;\n                      newObj.onGround = true;\n                  } \n                  else {\n                      if ((newObj.velocity.x > 0 && newObj.position.x + newObj.width <= platform.position.x) || (newObj.velocity.x < 0 && newObj.position.x >= platform.position.x + platform.width)) {\n                        nextPos.x = newObj.position.x;\n                        newObj.velocity.x = 0;\n                         if ('facing' in newObj && newObj.type === NinjaType.Patroller) {\n                             (newObj as Enemy).facing = (newObj as Enemy).facing === 'left' ? 'right' : 'left';\n                         }\n                      }\n                      if(newObj.velocity.y < 0 && newObj.position.y >= platform.position.y + platform.height){\n                         nextPos.y = newObj.position.y;\n                         newObj.velocity.y = 0;\n                      }\n                  }\n              }\n          }\n      }\n\n      newObj.position = nextPos;\n      \n      newObj.position.x = Math.max(0, Math.min(levelData.mapDimensions.width - newObj.width, newObj.position.x));\n      if (newObj.position.y > levelData.mapDimensions.height) {\n          if ('health' in newObj) newObj.health = 0;\n      }\n      \n      return newObj;\n  }, [platforms, levelData.mapDimensions]);\n  \n  const gameLoopCallback = useCallback((deltaTime: number) => {\n    const gameArea = gameAreaRef.current;\n    if (!gameArea) return;\n\n    // --- Player Logic ---\n    setPlayer(p => {\n      let newPlayer = { ...p };\n      if (controls.keys.has('a') || controls.keys.has('arrowleft')) {\n          newPlayer.velocity.x = -PLAYER_HORIZONTAL_SPEED;\n          newPlayer.facing = 'left';\n      } else if (controls.keys.has('d') || controls.keys.has('arrowright')) {\n          newPlayer.velocity.x = PLAYER_HORIZONTAL_SPEED;\n          newPlayer.facing = 'right';\n      } else {\n          newPlayer.velocity.x *= FRICTION;\n          if (Math.abs(newPlayer.velocity.x) < 0.1) newPlayer.velocity.x = 0;\n      }\n\n      if ((controls.keys.has('w') || controls.keys.has('arrowup')) && newPlayer.onGround) {\n          newPlayer.velocity.y = -PLAYER_JUMP_FORCE;\n          newPlayer.onGround = false;\n      }\n\n      const rect = gameArea.getBoundingClientRect();\n      const playerScreenX = rect.left + rect.width / 2;\n      const playerScreenY = rect.top + rect.height / 2;\n      newPlayer.angle = Math.atan2(controls.mouse.position.y - playerScreenY, controls.mouse.position.x - playerScreenX);\n      \n      return applyPhysics(newPlayer, deltaTime) as Player;\n    });\n\n    // --- Shooting ---\n    const now = Date.now();\n    if (controls.mouse.isDown && ammo > 0 && now - lastShotTime.current > SHOOT_COOLDOWN) {\n      lastShotTime.current = now;\n      setAmmo(a => a - 1);\n      setBullets(b => [...b, {\n        id: `bullet-${now}`,\n        position: {x: player.position.x + player.width/2, y: player.position.y + player.height/2},\n        width: BULLET_SIZE,\n        height: BULLET_SIZE,\n        angle: player.angle\n      }]);\n    }\n    \n    // --- Update Bullets ---\n    setBullets(prevBullets => {\n      return prevBullets.map(bullet => ({\n          ...bullet,\n          position: {\n            x: bullet.position.x + Math.cos(bullet.angle) * BULLET_SPEED,\n            y: bullet.position.y + Math.sin(bullet.angle) * BULLET_SPEED,\n          }\n      })).filter(b => \n        b.position.x > 0 && b.position.x < levelData.mapDimensions.width &&\n        b.position.y > 0 && b.position.y < levelData.mapDimensions.height &&\n        !platforms.some(p => checkAABBCollision(b, p))\n      );\n    });\n\n    // --- Update Enemies ---\n    setEnemies(prevEnemies => {\n      let newBullets = [...bullets];\n      let newScore = score;\n      const updatedEnemies = prevEnemies.map(enemy => {\n        let newEnemy = { ...enemy };\n        \n        const directionToPlayerX = player.position.x - newEnemy.position.x;\n        const directionToPlayerY = player.position.y - newEnemy.position.y;\n        const distance = Math.sqrt(directionToPlayerX * directionToPlayerX + directionToPlayerY * directionToPlayerY);\n\n        switch(newEnemy.type) {\n            case NinjaType.Chaser:\n            case NinjaType.Brute:\n            case NinjaType.Oni:\n                newEnemy.velocity.x = Math.sign(directionToPlayerX) * newEnemy.speed;\n                newEnemy.facing = Math.sign(directionToPlayerX) > 0 ? 'right' : 'left';\n                break;\n            case NinjaType.Specter:\n                newEnemy.velocity.x = (directionToPlayerX / distance) * newEnemy.speed;\n                newEnemy.velocity.y = (directionToPlayerY / distance) * newEnemy.speed;\n                newEnemy.facing = Math.sign(directionToPlayerX) > 0 ? 'right' : 'left';\n                break;\n            case NinjaType.Patroller:\n                if (newEnemy.onGround) {\n                    newEnemy.velocity.x = newEnemy.facing === 'right' ? newEnemy.speed : -newEnemy.speed;\n                }\n                break;\n        }\n        \n        newEnemy = applyPhysics(newEnemy, deltaTime) as Enemy;\n\n        if (checkAABBCollision(player, newEnemy)) {\n          setPlayer(p => ({ ...p, health: Math.max(0, p.health - 0.5) }));\n        }\n\n        return newEnemy;\n      }).filter(enemy => {\n        if (enemy.health <= 0) return false;\n        const hitBulletIndex = newBullets.findIndex(b => checkAABBCollision(b, enemy));\n        if (hitBulletIndex > -1) {\n          enemy.health -= 1;\n          newBullets.splice(hitBulletIndex, 1);\n          if (enemy.health <= 0) {\n            newScore += enemy.value;\n            return false;\n          }\n        }\n        return true;\n      });\n      setBullets(newBullets);\n      setScore(newScore);\n      return updatedEnemies;\n    });\n\n    // --- Ammo pack collision ---\n    setAmmoPacks(prevPacks => {\n        return prevPacks.filter(pack => {\n            if(checkAABBCollision(player, pack)) {\n                setAmmo(a => a + pack.amount);\n                return false;\n            }\n            return true;\n        })\n    });\n  }, [controls, player, ammo, score, bullets, levelData, platforms, applyPhysics]);\n\n  useGameLoop(gameLoopCallback);\n\n  useEffect(() => {\n    updateStats({ health: Math.round(player.health), ammo, score });\n    if (player.health <= 0) {\n      onGameOver(score);\n    } else if (enemies.length === 0) {\n      onLevelComplete(score);\n    }\n  }, [player.health, ammo, score, enemies.length, onGameOver, onLevelComplete, updateStats]);\n\n  const viewportWidth = gameAreaRef.current?.clientWidth || window.innerWidth;\n  const viewportHeight = gameAreaRef.current?.clientHeight || window.innerHeight;\n\n  const worldStyle = {\n    '--world-x': `${-(player.position.x - viewportWidth / 2)}px`,\n    '--world-y': `${-(player.position.y - viewportHeight / 2)}px`,\n  } as React.CSSProperties;\n\n  return (\n    <div ref={gameAreaRef} className=\"w-full h-full bg-gray-900 cursor-crosshair overflow-hidden relative\" style={worldStyle}>\n      <div className=\"absolute top-0 left-0 transition-transform duration-100 ease-linear\" style={{ transform: `translate(var(--world-x), var(--world-y))` }}>\n        <div className=\"absolute bg-grid-pattern\" style={{ width: levelData.mapDimensions.width, height: levelData.mapDimensions.height, background: 'linear-gradient(to bottom, #2c3e50, #34495e)'}}></div>\n        \n        {platforms.map(o => (\n          <div key={o.id} className=\"absolute bg-gray-700 border-b-4 border-gray-800\" style={{'--x': `${o.position.x}px`, '--y': `${o.position.y}px`, '--w': `${o.width}px`, '--h': `${o.height}px`, left: 'var(--x)', top: 'var(--y)', width: 'var(--w)', height: 'var(--h)'} as React.CSSProperties}></div>\n        ))}\n        \n        {ammoPacks.map(a => (\n            <div key={a.id} className=\"absolute flex items-center justify-center text-3xl\" style={{ '--x': `${a.position.x}px`, '--y': `${a.position.y}px`, '--w': `${a.width}px`, '--h': `${a.height}px`, left: 'var(--x)', top: 'var(--y)', width: 'var(--w)', height: 'var(--h)' } as React.CSSProperties}>\n                💰\n            </div>\n        ))}\n\n        {enemies.map(e => (\n          <div key={e.id} className={`absolute flex items-center justify-center rounded-sm border-2 border-black ${NINJA_STATS[e.type].color}`} style={{'--x': `${e.position.x}px`, '--y': `${e.position.y}px`, '--w': `${e.width}px`, '--h': `${e.height}px`, transform: `scaleX(${e.facing === 'right' ? 1 : -1})`, left: 'var(--x)', top: 'var(--y)', width: 'var(--w)', height: 'var(--h)'} as React.CSSProperties}>\n             <div className=\"w-1/2 h-4 bg-gray-200\" style={{ clipPath: 'polygon(50% 0%, 100% 100%, 0% 100%)' }}></div>\n          </div>\n        ))}\n\n        {bullets.map(b => (\n          <div key={b.id} className=\"absolute text-yellow-400 text-2xl shuriken\" style={{'--x': `${b.position.x}px`, '--y': `${b.position.y}px`, '--w': `${b.width}px`, '--h': `${b.height}px`, left: 'var(--x)', top: 'var(--y)', width: 'var(--w)', height: 'var(--h)'} as React.CSSProperties}>\n            🌟\n          </div>\n        ))}\n        \n        <div className=\"absolute transition-transform duration-75\" style={{'--x': `${player.position.x}px`, '--y': `${player.position.y}px`, '--w': `${player.width}px`, '--h': `${player.height}px`, transform: `scaleX(${player.facing === 'right' ? 1 : -1})`, left: 'var(--x)', top: 'var(--y)', width: 'var(--w)', height: 'var(--h)'} as React.CSSProperties}>\n            <div className=\"w-full h-full bg-indigo-500 rounded-sm flex items-center justify-center text-white font-bold text-2xl border-2 border-indigo-300\">\n                🥷\n            </div>\n        </div>\n\n      </div>\n    </div>\n  );\n};\n\nexport default GameScreen;\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nTypeScript\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE components/GameScreen.tsx ---\n--- START OF FILE App.tsx ---\n\nGenerated typescript\nimport React, { useState, useCallback, useEffect } from 'react';\nimport { GameState, GameMode, NinjaType, LevelData } from './types';\nimport { LEVELS, INITIAL_AMMO, PLAYER_HEALTH, SURVIVAL_LEVEL } from './constants';\nimport GameScreen from './components/GameScreen';\nimport HUD from './components/HUD';\n\nconst App: React.FC = () => {\n  const [gameState, setGameState] = useState<GameState>(GameState.StartScreen);\n  const [gameMode, setGameMode] = useState<GameMode>(GameMode.Campaign);\n  const [currentLevel, setCurrentLevel] = useState(1);\n  const [currentWave, setCurrentWave] = useState(1);\n  const [maxLevelReached, setMaxLevelReached] = useState(() => {\n    try {\n      const savedMaxLevel = localStorage.getItem('maxLevelReached');\n      return savedMaxLevel ? parseInt(savedMaxLevel, 10) : 1;\n    } catch (error) {\n      console.error(\"Could not parse maxLevelReached from localStorage\", error);\n      return 1;\n    }\n  });\n  const [score, setScore] = useState(0);\n  const [finalScore, setFinalScore] = useState(0);\n  const [gameWon, setGameWon] = useState(false);\n  \n  const [hudStats, setHudStats] = useState({\n    health: PLAYER_HEALTH,\n    ammo: INITIAL_AMMO,\n    score: 0,\n  });\n  \n  useEffect(() => {\n      try {\n        localStorage.setItem('maxLevelReached', maxLevelReached.toString());\n      } catch(error) {\n        console.error(\"Could not save maxLevelReached to localStorage\", error);\n      }\n  }, [maxLevelReached]);\n\n  const startGame = (mode: GameMode, level = 1) => {\n    setGameMode(mode);\n    setScore(0);\n    setGameWon(false);\n    setHudStats({ health: PLAYER_HEALTH, ammo: INITIAL_AMMO, score: 0 });\n\n    if (mode === GameMode.Campaign) {\n      setCurrentLevel(level);\n    } else {\n      setCurrentWave(1);\n    }\n    setGameState(GameState.Playing);\n  };\n  \n  const startNextLevel = () => {\n     if (gameMode === GameMode.Campaign) {\n        setGameState(GameState.Playing);\n     }\n  };\n\n  const handleLevelComplete = useCallback((newScore: number) => {\n    setScore(newScore);\n    if (gameMode === GameMode.Campaign) {\n        const nextLevel = currentLevel + 1;\n        if (nextLevel > maxLevelReached) {\n          setMaxLevelReached(nextLevel);\n        }\n        \n        if (currentLevel < LEVELS.length) {\n          setCurrentLevel(prev => prev + 1);\n          setGameState(GameState.LevelComplete);\n        } else {\n          setFinalScore(newScore);\n          setGameWon(true);\n          setGameState(GameState.GameOver);\n        }\n    } else { // Survival Mode\n        setCurrentWave(prev => prev + 1);\n        setHudStats(prev => ({...prev, ammo: prev.ammo + 20})); // bonus ammo\n        setGameState(GameState.Playing); // Immediately start next wave\n    }\n  }, [currentLevel, maxLevelReached, gameMode]);\n  \n  const handleGameOver = useCallback((finalScoreValue: number) => {\n    setFinalScore(finalScoreValue);\n    setGameWon(false);\n    setGameState(GameState.GameOver);\n  }, []);\n  \n  const updateStats = useCallback((stats: { health: number; ammo: number; score: number }) => {\n    setHudStats(stats);\n  }, []);\n  \n  const goToMenu = () => {\n    setGameState(GameState.StartScreen);\n  }\n\n  const generateSurvivalEnemies = (wave: number): LevelData['enemies'] => {\n      const enemies = [];\n      const { width, height } = SURVIVAL_LEVEL.mapDimensions;\n      \n      const patrollerCount = Math.floor(wave * 1.5);\n      const chaserCount = Math.floor(wave / 2);\n      const specterCount = Math.floor(wave / 3);\n      const bruteCount = Math.floor(wave / 4);\n      const oniCount = Math.floor(wave / 6);\n\n      for(let i=0; i < patrollerCount; i++) enemies.push({type: NinjaType.Patroller, position: {x: Math.random() * (width - 100) + 50, y: height - 100}});\n      for(let i=0; i < chaserCount; i++) enemies.push({type: NinjaType.Chaser, position: {x: Math.random() * (width - 100) + 50, y: height - 100}});\n      for(let i=0; i < specterCount; i++) enemies.push({type: NinjaType.Specter, position: {x: Math.random() * (width - 100) + 50, y: Math.random() * (height - 200)}});\n      for(let i=0; i < bruteCount; i++) enemies.push({type: NinjaType.Brute, position: {x: Math.random() * (width - 100) + 50, y: height - 120}});\n      for(let i=0; i < oniCount; i++) enemies.push({type: NinjaType.Oni, position: {x: Math.random() * (width - 100) + 50, y: height - 150}});\n      \n      return enemies;\n  }\n\n  const renderContent = () => {\n    switch (gameState) {\n      case GameState.StartScreen:\n        return (\n          <div className=\"text-center text-white\">\n            <h1 className=\"text-6xl font-bold font-mono mb-4 text-red-500 drop-shadow-[0_4px_2px_rgba(0,0,0,0.5)]\">NINJA RAMPAGE</h1>\n            <p className=\"text-xl mb-8 max-w-2xl mx-auto\">Use <span className=\"text-yellow-300 font-bold\">A/D</span> or <span className=\"text-yellow-300 font-bold\">Arrow Keys</span> to move, and <span className=\"text-yellow-300 font-bold\">W</span> to jump. Aim with your mouse and click to throw shurikens.</p>\n            <div className=\"flex justify-center gap-8\">\n                <button\n                  onClick={() => startGame(GameMode.Survival)}\n                  className=\"px-8 py-4 bg-purple-600 hover:bg-purple-700 text-white font-bold text-2xl rounded-lg shadow-lg transform hover:scale-105 transition-transform\"\n                >\n                  Survival Mode\n                </button>\n            </div>\n            <div className=\"mt-8\">\n              <h2 className=\"text-3xl font-mono mb-4\">Campaign Mode</h2>\n              <div className=\"flex justify-center gap-4 flex-wrap\">\n                {LEVELS.map(level => (\n                  <button\n                    key={level.level}\n                    disabled={level.level > maxLevelReached}\n                    onClick={() => startGame(GameMode.Campaign, level.level)}\n                    className=\"px-6 py-3 bg-gray-700 hover:bg-gray-600 text-white font-bold text-xl rounded-lg shadow-md transform hover:scale-105 transition-transform disabled:bg-gray-800 disabled:text-gray-500 disabled:cursor-not-allowed disabled:transform-none\"\n                  >\n                    Level {level.level}\n                  </button>\n                ))}\n              </div>\n            </div>\n          </div>\n        );\n      case GameState.LevelComplete:\n        return (\n          <div className=\"text-center text-white\">\n            <h1 className=\"text-5xl font-bold font-mono mb-4 text-blue-400\">Level {currentLevel - 1} Complete!</h1>\n            <p className=\"text-2xl mb-2\">Current Score: {score}</p>\n            <p className=\"text-xl mb-8\">The next challenge awaits...</p>\n            <button\n              onClick={startNextLevel}\n              className=\"px-8 py-4 bg-blue-500 hover:bg-blue-600 text-white font-bold text-2xl rounded-lg shadow-lg transform hover:scale-105 transition-transform mr-4\"\n            >\n              Next Level\n            </button>\n            <button\n              onClick={goToMenu}\n              className=\"px-8 py-4 bg-gray-500 hover:bg-gray-600 text-white font-bold text-2xl rounded-lg shadow-lg transform hover:scale-105 transition-transform\"\n            >\n              Main Menu\n            </button>\n          </div>\n        );\n      case GameState.GameOver:\n        return (\n          <div className=\"text-center text-white\">\n            <h1 className=\"text-6xl font-bold font-mono mb-4 text-red-500\">\n                {gameWon ? \"VICTORY!\" : \"YOU DIED\"}\n            </h1>\n            <p className=\"text-3xl mb-2\">Final Score: <span className=\"font-bold text-yellow-300\">{finalScore}</span></p>\n            {gameMode === GameMode.Survival && <p className=\"text-2xl mb-8\">You survived until Wave: <span className=\"font-bold text-red-400\">{currentWave}</span></p>}\n            <button\n              onClick={goToMenu}\n              className=\"px-8 py-4 bg-red-600 hover:bg-red-700 text-white font-bold text-2xl rounded-lg shadow-lg transform hover:scale-105 transition-transform\"\n            >\n              Main Menu\n            </button>\n          </div>\n        );\n      case GameState.Playing:\n        let levelData: LevelData;\n        if (gameMode === GameMode.Campaign) {\n            levelData = LEVELS[currentLevel - 1];\n        } else {\n            levelData = {\n                ...SURVIVAL_LEVEL,\n                level: currentWave,\n                enemies: generateSurvivalEnemies(currentWave),\n                ammoPacks: currentWave % 3 === 0 ? [{ position: { x: SURVIVAL_LEVEL.mapDimensions.width / 2, y: SURVIVAL_LEVEL.mapDimensions.height / 2 }, amount: 25 }] : [],\n            }\n        }\n        \n        if (!levelData) {\n            handleGameOver(score);\n            return null;\n        }\n        return (\n          <>\n            <HUD\n              health={hudStats.health}\n              ammo={hudStats.ammo}\n              score={hudStats.score}\n              level={currentLevel}\n              wave={currentWave}\n              gameMode={gameMode}\n            />\n            <GameScreen\n              key={gameMode === GameMode.Campaign ? currentLevel : `survival-${currentWave}`}\n              levelData={levelData}\n              initialAmmo={hudStats.ammo}\n              initialScore={score}\n              onLevelComplete={handleLevelComplete}\n              onGameOver={handleGameOver}\n              updateStats={updateStats}\n            />\n          </>\n        );\n    }\n  };\n\n  return (\n    <main className=\"w-screen h-screen bg-gray-900 flex items-center justify-center font-sans overflow-hidden relative\">\n        <div className=\"absolute inset-0 bg-[url('https://www.transparenttextures.com/patterns/dark-matter.png')] opacity-20\"></div>\n        {renderContent()}\n        <div className=\"absolute inset-0 pointer-events-nonecrt-lines\"></div>\n        <style>{`\n          .crt-lines::before {\n            content: \" \";\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            bottom: 0;\n            right: 0;\n            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));\n            z-index: 2;\n            background-size: 100% 4px, 3px 100%;\n            pointer-events: none;\n          }\n           @keyframes spin {\n               from { transform: rotate(0deg); }\n               to { transform: rotate(360deg); }\n           }\n           .shuriken {\n              display: inline-block;\n              animation: spin 0.4s linear infinite;\n           }\n           @keyframes flicker {\n            0% { opacity: 0.27861; } 5% { opacity: 0.34769; } 10% { opacity: 0.23604; } 15% { opacity: 0.90626; } 20% { opacity: 0.18128; } 25% { opacity: 0.83891; } 30% { opacity: 0.65583; } 35% { opacity: 0.67807; } 40% { opacity: 0.26559; } 45% { opacity: 0.84693; } 50% { opacity: 0.96019; } 55% { opacity: 0.08594; } 60% { opacity: 0.20313; } 65% { opacity: 0.71988; } 70% { opacity: 0.53455; } 75% { opacity: 0.37288; } 80% { opacity: 0.71428; } 85% { opacity: 0.70428; } 90% { opacity: 0.7003; } 95% { opacity: 0.36108; } 100% { opacity: 0.24387; }\n          }\n          .bg-grid-pattern {\n            background-image:\n              linear-gradient(to right, rgba(255, 255, 255, 0.05) 1px, transparent 1px),\n              linear-gradient(to bottom, rgba(255, 255, 255, 0.05) 1px, transparent 1px);\n            background-size: 50px 50px;\n          }\n        `}</style>\n    </main>\n  );\n};\n\nexport default App;\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nTypeScript\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE App.tsx ---\n--- START OF FILE package.json ---\n\nGenerated json\n{\n  \"name\": \"ninja-rampage\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"react\": \"^19.1.1\",\n    \"react-dom\": \"^19.1.1\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^22.14.0\",\n    \"typescript\": \"~5.8.2\",\n    \"vite\": \"^6.2.0\"\n  }\n}\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nJson\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE package.json ---\n--- START OF FILE index.html ---\n\nGenerated html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Ninja Rampage</title>\n    <script src=\"https://cdn.tailwindcss.com\"></script>\n  <script type=\"importmap\">\n{\n  \"imports\": {\n    \"react/\": \"https://esm.sh/react@^19.1.1/\",\n    \"react\": \"https://esm.sh/react@^19.1.1\",\n    \"react-dom/\": \"https://esm.sh/react-dom@^19.1.1/\"\n  }\n}\n</script>\n<link rel=\"stylesheet\" href=\"/index.css\">\n</head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/index.tsx\"></script>\n  </body>\n</html>\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nHtml\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE index.html ---\n--- START OF FILE index.tsx ---\n\nGenerated typescript\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst rootElement = document.getElementById('root');\nif (!rootElement) {\n  throw new Error(\"Could not find root element to mount to\");\n}\n\nconst root = ReactDOM.createRoot(rootElement);\nroot.render(\n    <App />\n);\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nTypeScript\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE index.tsx ---\n--- START OF FILE tsconfig.json ---\n\nGenerated json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"experimentalDecorators\": true,\n    \"useDefineForClassFields\": false,\n    \"module\": \"ESNext\",\n    \"lib\": [\n      \"ES2022\",\n      \"DOM\",\n      \"DOM.Iterable\"\n    ],\n    \"skipLibCheck\": true,\n    \"moduleResolution\": \"bundler\",\n    \"isolatedModules\": true,\n    \"moduleDetection\": \"force\",\n    \"allowJs\": true,\n    \"jsx\": \"react-jsx\",\n    \"paths\": {\n      \"@/*\": [\n        \"./*\"\n      ]\n    },\n    \"allowImportingTsExtensions\": true,\n    \"noEmit\": true\n  }\n}\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nJson\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE tsconfig.json ---\n--- START OF FILE vite.config.ts ---\n\nGenerated typescript\nimport path from 'path';\nimport { defineConfig, loadEnv } from 'vite';\n\nexport default defineConfig(({ mode }) => {\n    const env = loadEnv(mode, '.', '');\n    return {\n      define: {\n        'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),\n        'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)\n      },\n      resolve: {\n        alias: {\n          '@': path.resolve(__dirname, '.'),\n        }\n      }\n    };\n});\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nTypeScript\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE vite.config.ts ---\n--- START OF FILE README.md ---\n\nGenerated markdown\n# Run and deploy your AI Studio app\n\nThis contains everything you need to run your app locally.\n\n## Run Locally\n\n**Prerequisites:**  Node.js\n\n\n1. Install dependencies:\n   `npm install`\n2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key\n3. Run the app:\n   `npm run dev`\nIGNORE_WHEN_COPYING_START\ncontent_copy\ndownload\nUse code with caution.\nMarkdown\nIGNORE_WHEN_COPYING_END\n\n--- END OF FILE README.md ---\" can you assist in completing a ninja game? Many thanks!\nand also game design of \"### 1. Enemy Ninja Functions (AI Behavior)\nEnemy ninjas should have multiple movement and attack patterns to create diverse challenges. We can define several enemy types:\n- **Patrolling Ninja**: Moves along a fixed path (waypoints). When the player is detected (within a cone of vision and a certain distance), the enemy will stop patrolling and either:\n  - Approach the player (if in melee range) and use a melee attack.\n  - Throw shurikens (if at a distance) and take cover (if cover is available).\n- **Sniper Ninja**: Stationary or moves between predefined sniper nests. When the player is in line of sight (and within a long range), the sniper will aim for a short duration and then fire a high-damage projectile. The player can see a laser sight as a warning.\n- **Chasing Ninja (Hound)**: Once the player is detected (by any enemy or by a trigger), this enemy will actively chase the player. It can jump over gaps and climb short walls. It moves faster than the player and uses a melee attack upon reaching the player.\n- **Stealth Ninja**: Can become invisible (with a shimmer effect) and moves quietly. It will try to flank the player and attack from behind. The player can detect them by listening for footsteps or by using a special item (like a smoke bomb that reveals hidden enemies).\n- **Bomber Ninja**: Throws timed explosives or grenades at the player. The grenades have a fuse and can be avoided by moving away. The bomber will try to maintain a safe distance.\n**Movement Details**:\n- Enemies should use pathfinding (like A* algorithm) to navigate the level, avoiding obstacles and walls.\n- They can have abilities like jumping, climbing, crouching, and rolling to traverse the environment and dodge player attacks.\n### 2. Main Character Mechanisms\nThe player (main ninja) should have a set of abilities to counter the enemies:\n- **Movement**: Run, jump, double jump, crouch, climb walls (for a short duration), and dash (quick movement in a direction to dodge).\n- **Attack**:\n  - Primary: Melee (sword) attack in front (with combo system) or throwing shurikens (limited ammo, but can be picked up).\n  - Secondary: Special weapons (like kunai, smoke bombs, explosive tags) that can be selected from an inventory and have limited uses.\n- **Defense**: Block (reduces damage) and parry (if timed correctly, stuns the enemy and allows for a counterattack).\n- **Stealth**: The player can hide in shadows (if the level has dark areas) or behind objects to avoid detection.\n### 3. Ammo and Item Functions\n- **Shuriken**: Basic ammo, thrown in a straight line. Can be picked up from defeated enemies or found in crates.\n- **Kunai**: Heavier than shurikens, can break certain obstacles (like wooden barriers) and cause more damage. Limited carry capacity.\n- **Smoke Bomb**: Creates a cloud of smoke that obscures vision. Enemies inside the smoke become confused (temporarily lose track of the player). Also reveals stealth enemies in the smoke.\n- **Explosive Tag**: Can be placed on walls or floors and detonated remotely. Useful for destroying obstacles or groups of enemies.\n- **Health Potion**: Restores a portion of health.\n- **Ninja Scroll (Temporary Power-up)**: Grants a special ability for a limited time (e.g., increased speed, invisibility, or one-hit kill melee).\n### 4. Environment: Paths, Walls, and Collision\n- **Paths**: Levels should have multiple paths (some hidden) that the player can take. These can be:\n  - Ground paths (with cover objects like crates, trees, rocks).\n  - Elevated paths (platforms, rooftops) that require jumping or climbing.\n  - Underground tunnels (entrances hidden behind breakable walls).\n- **Walls and Obstacles**:\n  - **Solid Walls**: Impassable and block all projectiles.\n  - **Breakable Walls**: Can be destroyed by explosives or heavy attacks to reveal secrets or new paths.\n  - **Climbable Walls**: Marked with a texture (like vines or ladder). The player can climb for a limited time (stamina system) or until the top is reached.\n- **Collision and Stuck Prevention**:\n  - Use a **collision map** that defines walkable and non-walkable areas.\n  - Implement **collision boxes (hitboxes)** for all entities (player, enemies, items) and static objects (walls, obstacles). Use rectangle or polygon collision.\n  - For preventing \"stuck in walls\" bugs:\n    - During movement, check for collisions in the intended direction before moving the entity.\n    - If a collision is detected, adjust the movement vector to slide along the obstacle (using the normal of the collision surface).\n    - Use a small \"skin\" around the collision box to avoid getting too close to walls.\n    - Implement a \"recovery\" system: if an entity is stuck (e.g., overlapping with a wall for more than a few frames), move it to the nearest valid position.\""
}